<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE Rule PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<Rule language="beanshell" name="STS Restore Accounts_Groups Rule">
    <Description>This rule will restore accounts and gropups for server that have crashed.
    </Description>
    <Source>
        <![CDATA[
            import sailpoint.object.Identity;
            import sailpoint.object.Application;
            import sailpoint.object.Link;
            import sailpoint.object.ManagedAttribute;
            import sailpoint.object.QueryOptions;
            import sailpoint.object.Schema;
            import sailpoint.object.ProvisioningProject;
            import sailpoint.object.ProvisioningPlan;
            import sailpoint.object.ProvisioningPlan.ObjectRequest;
            import sailpoint.object.ProvisioningPlan.AccountRequest;
            import sailpoint.object.ProvisioningResult;
            import sailpoint.object.ProvisioningPlan.AttributeRequest;

            import sailpoint.api.ManagedAttributer;
            import sailpoint.api.Provisioner;
            import sailpoint.api.IdentityService;

            import sailpoint.tools.Util;
            import sailpoint.tools.Message;
            import sailpoint.tools.GeneralException;
            
            import java.lang.Exception;
            import org.apache.log4j.Logger;
            import org.apache.log4j.Level;

            Logger rlogger = Logger.getLogger("sts.rule.RestoreAccountsGroups");
            String logLevel = "OFF";
            if (Boolean.parseBoolean(config.get("enableLogging"))) {
                logLevel = config.get("logLevel");
            }
            rlogger.setLevel(Level.toLevel(null!=logLevel?logLevel:"OFF"));

            rlogger.trace("Entering Restore Accounts and Groups Rule");

//--- New by Antonio Cano. Get the Native Application password history for a specificIdentity ---
public String getAccountPassHist(String applicationId, Identity identity) //---, SailPointContext context) 
		throws GeneralException
{
	String passHist = null;
	IdentityService  identityService = null;
	Link             nativeApp = null;

    rlogger.debug("[ getAccountPassHistory ] Entering ...applicationId = '" + applicationId + "'");
	
	identityService = new IdentityService(context);
	
	nativeApp = identityService.getLinkById(identity, applicationId);
	
	if (nativeApp != null)
	  passHist = nativeApp.getPasswordHistory(); //--- return CSV list of passwords ---

    rlogger.debug("[ getAccountPassHist ] Leaving ... passHist = '" + passHist + "'.");
	
	return passHist;
}


            /* Batch task to restore user accounts, including passwords and gropups after server crash */
            private int createGroups(String applicationName, String applicationId, String singleGroup) {
            
                rlogger.debug("[ createGroups ] Entering ...");
            
                taskResult.addMessage(Message.info("Restoring groups for application " + applicationName, null));
                ObjectRequest objtReq;
                int recCount = 0;
                String  value, groupDisplayName, attrName, groupWhereClause = (null!=singleGroup?"ma.value = '" + singleGroup + "' and ":""),
                        hqlQuery = "SELECT ma.value, ma.displayName, ma.attribute from ManagedAttribute as ma where " + groupWhereClause + "ma.application.name='" + applicationName + "'";
                Object attrVal;
                Schema groupSchema;
                ProvisioningPlan plan;
                Iterator itGroups = context.search(hqlQuery, null, new QueryOptions());
                Object [] groups;
                ManagedAttribute accountGroup;
                Map objtReqMap = Util.stringToMap("[application=" + applicationName + ", op=Create, type=group]");
                List valueAttributeList = Util.csvToList("name,sAMAccountName");

                while (itGroups.hasNext()) {
                    recCount++;
                    groups = itGroups.next();
                    value = groups[0];
                    groupDisplayName = groups[1];
                    attributeName = groups[2];
                    if (rlogger.isInfoEnabled()) {
                        rlogger.info("Group:" + value + "::" + groupDisplayName);
                    }
                    accountGroup = ManagedAttributer.get(context, applicationId, attributeName, value);
                    objtReq = new ObjectRequest(objtReqMap);
                    objtReq.setNativeIdentity(value);
                    groupSchema = application.getSchema("group");
                    for (attrName : groupSchema.getAttributeNames()) {
                        attrVal = (valueAttributeList.contains(attrName)?accountGroup.getValue():accountGroup.getAttribute(attrName));
                        if (rlogger.isDebugEnabled()) rlogger.debug("Creating AttributeRequest for " + attrName);
                        objtReq.add(new AttributeRequest(attrName, ProvisioningPlan.Operation.Set, attrVal));
                    }
                    plan = new ProvisioningPlan();
                    plan.setTargetIntegration(applicationName);
                    plan.addObjectRequest(objtReq);
                    doProvisioning(plan, applicationName, value, "group");
                }
                Util.flushIterator(itGroups);
                taskResult.addMessage(Message.info("Groups for application " + applicationName + " have been restored.", null));
                
                rlogger.debug("[ createGroups ] Leaving ...");
                
                return recCount;
            }

            private int createAccounts(String applicationName, String applicationId, String singleAccount) {
            
                rlogger.debug("[ createAccounts ] Entering ...");
            
                String logMessage = "Restoring accounts for application " + applicationName;
                taskResult.addMessage(Message.info(logMessage, null));

                if (rlogger.isInfoEnabled() || rlogger.isAttached()) {
                    rlogger.info(logMessage);
                }

                ProvisioningPlan plan;
                Object [] identities;
                AccountRequest acctReq;
                Schema accountSchema;
                
                Identity identity;
                IdentityService identityService = new IdentityService(context);
                List pwdHist, acctReqs;
                int recCount = 0;
                String  identityName, identityDisplayName, nativeIdentity, accountDisplayName, prevIdentity, identiyPwd, //--- logMessage,
                        accountWhereClause = (null!=singleAccount?"link.nativeIdentity = '" + singleAccount + "' and ":""),
                        
                        hqlQuery = "SELECT idt.name, idt.displayName, link.nativeIdentity, link.displayName FROM Identity AS idt";
                        
                hqlQuery += " JOIN idt.links AS link WHERE " + accountWhereClause + "link.application.id='" + applicationId + "' ORDER BY idt.name";
                
                Iterator itIdentities = context.search(hqlQuery, null, new QueryOptions());

                while (itIdentities.hasNext()) {
                    recCount++;
                    identities = itIdentities.next();
                    identityName = identities[0];
                    if (!identityName.equals(prevIdentity)) {
                        prevIdentity = identityName;
                        identitiesCnt++;
                        identityDisplayName = identities[1];
                        identity = context.getObjectByName(Identity.class, identityName);
                        plan = new ProvisioningPlan();
                        plan.setNativeIdentity(identityName);
                        plan.setIdentity(identity);
                        plan.setTargetIntegration(applicationName);
                     //--- Original code :   pwdHist = Util.csvToList(identity.getPasswordHistory());
                        pwdHist = getAccountPassHist(applicationId, identity);  //---context --
                        
                          rlogger.trace(" [ createAccounts ] pwdHist = '" + pwdHist + "'");
                        
                        if (!Util.isEmpty(pwdHist))
                      //--  String logMessage;
                        if (!Util.isEmpty(pwdHist)) {
                            identiyPwd = context.decrypt(pwdHist.get(0));
                            logMessage = "Password History available"; 
                            rlogger.trace(" [ createAccounts ] '" + logMessage + "'");
                            
                            taskResult.addMessage(Message.info(logMessage, null));
                            if (rlogger.isInfoEnabled()) rlogger.info(logMessage);
                        } else {
                            logMessage = "Password History missing, generating password for " + identityDisplayName;
                            
                             rlogger.trace(" [ createAccounts ] '" + logMessage + "'");
                             
                            taskResult.addMessage(Message.info(logMessage, null));
                            if (rlogger.isInfoEnabled()) rlogger.info(logMessage);
                            PasswordPolicy policy = context.getObject(PasswordPolicy.class, "Name of your password policy here");
                            try{
                                identiyPwd = new PasswordGenerator(context).generatePassword(policy);
                            } catch(Exception e){
                                identiyPwd = "p@ssw0rd!";
                                logMessage = "Failed to generate Password using password policy, setting default password for " + identityDisplayName;
                                taskResult.addMessage(Message.info(logMessage, null));
                                if (rlogger.isInfoEnabled()) rlogger.info(logMessage);
                            }
                        }
                    }
                    nativeIdentity = identities[2];
                    accountDisplayName = identities[3];
                    if (rlogger.isDebugEnabled()) {
                        rlogger.debug("Identity:" + identityName + "::" + identityDisplayName);
                        rlogger.debug("Account:" + nativeIdentity + "::" + accountDisplayName);
                        rlogger.debug("Creating AccountRequest...");
                    }
                    acctReqs = new ArrayList();
                    acctReq = new AccountRequest(AccountRequest.Operation.Create, applicationName, null, nativeIdentity);
                    accountSchema = application.getAccountSchema();
                    Link link = identityService.getLink(identity, application, null, nativeIdentity);
                    for (String attrName : accountSchema.getAttributeNames()) {
                        if (rlogger.isDebugEnabled()) rlogger.debug("Creating AttributeRequest for " + attrName);
                        acctReq.add(new AttributeRequest(attrName, ProvisioningPlan.Operation.Set, link.getAttribute(attrName)));
                    }
                    acctReq.add(new AttributeRequest("password", ProvisioningPlan.Operation.Set, identiyPwd));
                    acctReqs.add(acctReq);
                    plan.setAccountRequests(acctReqs);
                    doProvisioning(plan, applicationName, nativeIdentity, "account");
                }
                Util.flushIterator(itIdentities);
                context.decache(identity);
                logMessage = "Accounts for application " + applicationName + " have been restored.";
                taskResult.addMessage(Message.info(logMessage, null));
                if (rlogger.isInfoEnabled()) {
                    rlogger.info(logMessage);
                }
                
                rlogger.debug("[ createAccounts ] Leaving ...");
                
                return recCount;
            }

            private void doProvisioning(ProvisioningPlan plan, String applicationName, String nativeIdentity, String requestType) {
            
                rlogger.debug("[ doProvisioning ] Entering ...");
            
                Provisioner provisioner = new Provisioner(context);
                if (rlogger.isDebugEnabled()) rlogger.debug("Provisioning plan:\n" + plan.toXml());
                String logMessage;
                try {
                    provisioner.execute(plan);
                    Object provisioningRequest;
                    
                    if ("account".equals(requestType)) {
                        provisioningRequest = provisioner.getProject().getPlan(applicationName).getAccountRequest(applicationName, null, nativeIdentity);
                    } else {
                        provisioningRequest = provisioner.getProject().getPlan(applicationName).getObjectRequest(applicationName, null, nativeIdentity);
                    }
                    
                    if (rlogger.isDebugEnabled()) rlogger.debug(provisioningRequest.toXml());
                    
                    ProvisioningResult result = provisioningRequest.getResult();
                    if (!result.isCommitted()) {
                        logMessage = "Error occured during provisioning:" + Util.listToPipeDelimited(result.getErrors());
                        rlogger.warn(logMessage);
                        taskResult.addMessage(Message.warn(logMessage, null));
                    }
                } catch (Exception e){
                    logMessage = "Error occured during provisioning:" + e.getMessage();
                    rlogger.error(logMessage);
                    taskResult.addMessage(Message.error(logMessage, null));
                }
                
                rlogger.debug("[ doProvisioning ] Leaving ...");
                
            }

            /***************************************************
             * MAIN
             */
             rlogger.debug("[ Restore Accounts and Groups Rule ] Entering 'main' ...");
 
            String  applicationId = config.get("applicationId"), applicationName;
            int identitiesCnt = 0;

            rlogger.debug("[ Restore Accounts and Groups Rule ] applicationId = '" + applicationId + "'.");

//            Application application = context.getObjectById(Application.class, applicationId);
            Application application = context.getObjectByName(Application.class, applicationId);
            
            if (null!=application) {
                applicationName = application.getName();
            } else {
                return "Error";
            }
            
            String singleGroup = config.get("singleGroup");
            int groupsCnt = createGroups(applicationName, applicationId, singleGroup);
            
            String singleAccount = config.get("singleAccount");
            int accountsCnt = createAccounts(applicationName, applicationId, singleAccount);
            context.decache(application);

            taskResult.setAttribute("identitiesProcessed", identitiesCnt);
            taskResult.setAttribute("accountsProcessed", accountsCnt);
            taskResult.setAttribute("groupsProcessed", groupsCnt);
            
            rlogger.trace("Exiting... 'Restore Accounts and Groups Rule' ...");
            return "success";
        ]]>
    </Source>
</Rule>